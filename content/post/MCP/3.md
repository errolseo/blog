---
title: Model Context Protocol (3/3)
date: 2099-12-31
categories:
- MCP
thumbnailImage: /images/MCP/2/1.png
summary: " "
---
이전 글에서 Tool calling에 대해 알아보았습니다. 그러면 Tool calling을 잘 활용하기 위해서는 무엇이 필요할까요. IBM Reasearch의 <strong>Granite-Function Calling Model</strong>(Ibrahim Abdelaziz, et al. 2024)를 보면 Tool calling을 <strong>7가지 기본 작업</strong>으로 나누고 있습니다.

#### 3 종류의 Low-Level Task
- Function Name Detection
- Parameter-Value Pair Detection
- Next-Best Function
#### 3 종류의 High-Level Task
- Nested Function Calling
- Function Chaining
- Parallel Functions

그리고 Response Generation을 포함하여 총 7 종류 입니다.

여기서 Low-Level Task의 경우 사실상 하나의 Task로 볼 수 있습니다. {{<hl-text primary>}}단일 함수를 부를 경우{{</hl-text>}} 함수 목록 중에 최적의 함수를 찾아서(Next-Best Function) 함수 이름(Function Name Dection)과 매개변수(Parameter-Value Pair Detection)를 올바르게 생성해야는 것을 말합니다. 

#### High-Level Task
High-Level Task는 Tool calling 과정에서 여러 함수를 필요로 하는 작업들을 분류하고 설명합니다. 이 글에서는 관련 논문의 개념을 바탕으로 하되, 최신 모델의 발전 수준에 맞춰 세부 내용을 설명하겠습니다.

###### Nested Function Calling
다음 함수가 이전 함수의 출력에 종속되는 경우를 말합니다. 최근의 Tool calling의 경우 Planning을 거치기 보다는 단일 함수를 step-by-step으로 부릅니다.

```json
{"user": "회의실 빈 곳 찾아서 가장 빠른 시간으로 예약해 줘"}
{"assist": "[
  <tool_call>{'name': 'get_booking', 'arguments': {'date': '2025-07-09', 'room': 'All'}}</tool_call>,
  <tool_call>{'name': 'book_room', 'arguments': {<dependent on previous response>}}</tool_call>
]"}
```
`book_room`을 부르기 위해서는 반드시 `get_booking`의 결과가 필요합니다.

###### Function Chaining
다음 함수가 이전 함수의 출력에 종속되지 않는 경우를 말합니다. 서로 종속되지 않는 함수를 부르기에 복수의 함수를 호출하고 복수의 결과를 받아서 다음 step으로 넘어갑니다. (Overhead를 줄일 수 있나?)

```json
{"user": "콩의 효능과 콩 요리 레시피 알려줘"}
{"assist": "[
  <tool_call>{'name': 'search_benefits', 'arguments': {'item': 'bean'}}</tool_call>,
  <tool_call>{'name': 'search_recipes', 'arguments': {'item': 'bean'}}</tool_call>
]"}
```
이전 tool의 출력을 기다릴 필요 없이 동시에 실행할 수 있습니다.

###### Parallel Functions
동일한 함수를 여러 번 호출하는 경우를 말합니다.

```json
{"user": "3일 후 서울과 5일 후 부산의 날씨 알려줘"}
{"assist": "[
  <tool_call>{'name': 'get_weather', 'arguments': {'location': '서울', 'time_range': 3}}</tool_call>,
  <tool_call>{'name': 'get_weather', 'arguments': {'location': '부산', 'time_range': 5}}</tool_call>
]"}
```

서울과 부산 두 도시의 날씨 정보를 모두 호출해야 합니다. 한 곳의 정보만 호출할 경우 실패로 간주됩니다.
<br>

High-Level Task 또한 현재는 {{<hl-text primary>}}복수 함수를 부를 경우{{</hl-text>}} 하나의 작업으로 분류할 수 있습니다. 굳이 세세하기 나눌 필요 없을 정도로 모델의 성능 향상되었습니다.

#### Response Generation
Tool calling을 훌륭하게 완수했다 하더라도 본질은 대화형 인공지능이기에, User에게 보여줄 마지막 Assistant context가 제대로 출력되지 않는다면 사용 경험이 좋을 수 없습니다. LLM은 이전 json output들을 종합하여 알맞은 자연어 응답을 행성해내야 합니다.

> 오늘 사용할 수 있는 회의실은 AA, BB, CC 입니다. 그 중에 가장 빠른 시간 예약 가능한 회의실은 AA로 10:00-11:00에 사용 가능합니다. AA 회의실로 예약 완료하였습니다.

> 콩의 효능은 (...). 그리고 콩으로 만들 수 있는 요리는 (...).

> 3일 후 서울의 날씨는 (...). 그리고 5일 후 부산의 날씨는 (...).

위와 같이 마지막 출력물을 유저가 이해할 수 있는 텍스트 형태로 출력해주는 역량이 7가지 기본 작업 중, Response Generation에 해당합니다.

---
#### Reference
[Granite-Function Calling Model: Introducing Function Calling Abilities via Multi-task Learning of Granular Tasks](https://arxiv.org/abs/2407.00121v1) | Ibrahim Abdelaziz, et al.

---